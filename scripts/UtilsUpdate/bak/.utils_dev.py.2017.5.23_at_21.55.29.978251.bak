#! python3
# -*- coding: utf-8 -*-
__version__ = "1.0.0"
# f createdirs
# f createfile
# f savejson
# f loadjson
# f pathInWindowsWithSpacesToQuotes
# f pathInWindowsExtend
__version__ = "1.1.0"
# f taskkill
# f jsonload print "json loaded" output
# f jsonsave print "json saved" output
__version__ = "1.2.0"
# f file_wipe
__version__ = "1.3.0"
# f filebackup
# f jsonrestorebak todo
# f jsoncheck todo
# f timestamp
__version__ = "1.4.0"
# f screenblink
__version__ = "1.4.1"
# update pathInWindowsExtend - three path extend now
__version__ = "1.4.2"
# update pathInWindowsExtend - unlimited args now#
__version__ = "1.4.3"
# update pathInWindowsExtend - bugfix
__version__ = "1.4.4"
# update pathInWindowsExtend - bugfix
__version__ = "1.4.5"
# update screenblink - bugfix
__version__ = "1.4.6"
# update screenblink - bugfix
__version__ = "1.4.7"
# update screenblink - bugfix
__version__ = "1.4.8"
# update screenblink - bugfix
__version__ = "1.4.9"
# update screenblink - add change size of console window
__version__ = "1.5.0"
# f getOutPutFromCommand
# f getIntegers
# stringWidthNewlinesToString todo
# f checkWidthOfConsole
# update screenblink
__version__ = "1.5.1"
# enable new functionality in screenblink
# todoed вместо вывода кучи строк вывести одну длинную?
__version__ = "1.6.0"
# f homePath
__version__ = "1.6.1"
# loadjson warning expanded
__version__ = "1.7.0"
# f plog
# const newline
# f rustime
__version__ = "1.7.0"
# plog add custom time
# rustime add custom time
__version__ = "1.7.1"
# loadjson quiet option
__version__ = "1.7.2"
# filebackup quiet option
__version__ = "1.8.0"
# f ping
__version__ = "1.9.0"
# f currentfolder
__version__ = "1.9.1"
# gettime debug
# rustime update
__version__ = "1.10.0"
# f winRepair_UnicodeEncodeError
__version__ = "1.11.0"
# loadjson now create clean json if file not exist
# const ruble
# f cls
__version__ = "1.12.0"
# f dottedtime
__version__ = "1.13.0"
# f hidefile
# filebackup hidefile enable
__version__ = "1.14.0"
# f winRepair_UnicodeEncodeError
__version__ = "1.15.0"
# f doNothing
__version__ = "1.15.1"
# savejson now can be quiet
__version__ = "1.16.0"
# f deletefile
__version__ = "1.17.0"
# f bigdigits
__version__ = "1.18.0"
# f inputint
__version__ = "1.18.1"
# fix savejson
__version__ = "1.19.0"
# f isPython3
__version__ = "1.20.0"
# openInNewWindow todo debug
# f getDomainOfUrl
# enabled getDomainOfUrl in ping
# const backslash
# f substring (string, before, after=None)
__version__ = "1.21.0"
# f leftpad beta version todo fix all exceptions
__version__ = "1.22.0"
# allias to f currentfolder as currentdir
__version__ = "1.23.0"
# allias to f openInNewWindow as openInCurrentWindow
__version__ = "1.24.0"
# f openInCurrentWindow now isn't allias
__version__ = "1.25.0"
# f openInCurrentWindow doesn't work need fix
__version__ = "1.25.1"
# fix f openInCurrentWindow
__version__ = "1.25.2"
# fix get_time
__version__ = "1.26.0"
# f run_code
__version__ = "1.25.2"
# del f run_code(code): exec(code, globals()) (work only in local code)
__version__ = "1.26.0"
# f tkinter_color
__version__ = "1.26.1"
# loadjson, savejson print option
__version__ = "1.27.0"
# allias to_quotes pathInWindowsWithSpacesToQuotes(path)
__version__ = "1.28.0"
# f path_check
__version__ = "2.0.0"
# pathInWindowsExtend is crossplatfowm and now names path_extend # done
__version__ = "3.0.0"
# wipefile mow file_wipe
# deletefile now file_delete # done
# filebackup now  # done
# pathInWindowsWithSpacesToQuotes now path_to_quotes
# homePath now home_path  # done
# createfile now file_create  # done
__version__ = "4.0.0"
# file_backup now creates file in subfolder
# createdirs now dir_create # done
# wipefile now file_wipe
__version__ = "4.1.0"
# f close_all_gone_wrong(error_while, try_to_do)
__version__ = "4.2.0"
# f debug_print
__version__ = "4.2.1"
# add some tests
__version__ = "4.3.0"
# f get_os
__version__ = "4.3.1"
# add some crossplatformity
__version__ = "4.3.2"
# add some crossplatformity
__version__ = "4.3.3"
# add some crossplatformity
__version__ = "4.3.4aplha1"
# add some crossplatformity
__version__ = "4.3.4aplha2"
# add some crossplatformity plog, path_extend
__version__ = "5.0.0alpha1"
# hidefileWin now file_hide
# add some crossplatformity file_hide
# f file_rename
# f file_move
# file_hide bugfix
# add some crossplatformity ping
# path_check now path_full
__version__ = "5.0.0alpha2"
# rightpad bugfix
__version__ = "5.0.0alpha3"
# path_extend bugfix
__version__ = "5.0.0alpha4"
# path_extend bugfix
__version__ = "5.0.0alpha5"
# path_extend bugfix
__version__ = "5.0.0alpha6"
# path_extend bugfix
__version__ = "5.0.0alpha7"
# path_extend debugging
__version__ = "5.0.0alpha8"
# path_extend bugfix
__version__ = "5.1.0"
# file_backup now return backupfilename
__version__ = "5.1.1"
# path_extend bugfix
__version__ = "5.1.2"
# path_extend support for windows \\ip_or_pcname\paths
__version__ = "5.1.3"
# path_extend bugfix
__version__ = "5.1.4пизда"
# path_extend bugfix




# todo fix file_create

# todo countdown and 1 line option like "Sleep ** seconds..."
# todo version diff

import os, \
       json, \
       sys, \
       shutil, \
       time, \
       random, \
       subprocess, \
       datetime
from tkinter import *


def get_os():
    if sys.platform == "linux" or sys.platform == "linux2":
        return "linux"
    elif sys.platform == "win32" or sys.platform == "cygwin":
        return "windows"
    elif sys.platform == "darwin":
        return "macos"


import termcolor, \
       colorama

if get_os() == "windows":
    import win_unicode_console, \
           win32api, \
           win32con

#from path import path
#win_unicode_console.enable()
colorama.init()
colorama.deinit()
from termcolor import colored, cprint #print_green_on_cyan = lambda x: cprint(x, 'green', 'on_cyan')

newline = '\n'
ruble = u"\u20bd" # \u20bd is ₽
backslash = "\ "[:1]


def isPython3():
    PY3K = sys.version_info >= (3, 0)
    return PY3K


def path_full(path):
    return os.path.abspath(path)


def dir_create(filename):
    if os.path.isfile(filename):
        directory = os.path.dirname(filename)
    else:
        directory = filename
    if not os.path.exists(directory):
        os.makedirs(directory)


def file_create(filename):
    dir_create(filename)
    if not os.path.exists(filename):
        open(filename, 'a').close()
    if not os.path.exists(filename):
        close_all_gone_wrong("creating file " + str(filename), "script at path", path_full(sys.argv[0]))


def file_delete(path, quiet = False):
    try:
        os.remove(path)
        if not quiet:
            print("file", path, "is deleted")
    except PermissionError:
        try:
            subprocess.call(["del", path])
        except:
            print("file", path, "is not deleted")


def timestamp():
    ts = time.time()
    return ts


def currentfolder():
    return os.path.dirname(os.path.realpath(__file__))


def currentdir():
    return currentfolder()


def dottedtime():
    gettime = datetime.datetime.now()
    dateandtime = str(gettime.year) + "." + str(gettime.month) + "." + str(gettime.day) + "_at_" + str(gettime.hour) \
                  + "." + str(gettime.minute) + "." + str(gettime.second) + "." + str(gettime.microsecond)
    return dateandtime


def get_time(size):
    command = "str(datetime.datetime.now()." + size + ")"
    print(command)
    time_output = exec(command)
    print(time_output)
    return time_output


def file_move(input_file, output_file):
    shutil.move(input_file, output_file)


def file_rename(input_file, output_file):
    file_move(input_file, output_file)


def file_hide(filename, quiet=True):
    if get_os() == "windows":
        win32api.SetFileAttributes(filename, win32con.FILE_ATTRIBUTE_HIDDEN)
    dotted_file = os.path.split(filename)
    dotted_file_folder = dotted_file[0]
    dotted_file_name = dotted_file[1]
    dotted_file_name = "." + dotted_file_name
    dotted_file = path_extend(dotted_file_folder, dotted_file_name)
    file_rename(filename, dotted_file)
    if not quiet:
        print ("file", filename, "is hidden now")
    return dotted_file


def close_all_gone_wrong(error_while, try_to_repair):
    print("Error while", error_while)
    print("Try to repair", try_to_repair)
    print("Script is closing")
    sys.exit(1)


def debug_print(*arguments):
    print("Debug shit:")
    for arg in arguments:
        print("-" * checkWidthOfConsole(), end="")
        print(arg)
        print("-" * checkWidthOfConsole(), end="")


def file_backup(filename, subfolder="bak", quiet = False):
    filename = path_full(filename) # normalize filename
    backupfilename = str(filename) + "." + dottedtime() + ".bak"  # add dottedtime to backup filename
    backupfilename = os.path.split(backupfilename)  # splitting filename to folder and file
    try:  # if subfolder has no len
        if len(subfolder) < 1:  # if subfolder has non-zero len
            subfolder = "bak"  # set subfolder to default
            print("len(subfolder) < 1, so subfolder = 'bak'")  # print error
    except:  # if subfolder has no len
        subfolder = "bak"  # set subfolder to default
        print("len(subfolder) < 1, so subfolder = 'bak'")  # print error
    subfolder = path_extend(backupfilename[0], subfolder)  # append subfolder name
    dir_create(subfolder)  # create subfolder
    backupfilename = path_extend(subfolder, backupfilename[1])  # backup file name full path
    shutil.copy2(filename, backupfilename)  # finally backup file
    backupfilename = file_hide(backupfilename)  # hiding file
    if not os.path.isfile(backupfilename):  # if file is not created
        close_all_gone_wrong("backup file", "script at path " + path_full(sys.argv[0]))  # raise except
    if not quiet:  # if finction is not shutted up
        print("backup of file", filename, "created as", backupfilename) # all is ok, print that
    return backupfilename


def jsoncheck(filename):
    try:
        loadjson(filename)
    except:
        print("JSON is bad")


def savejson(filename, jsonstring, quiet=False, debug=False):
    try:
        settingsJsonTextIO = open(filename, "w")
        json.dump(jsonstring, settingsJsonTextIO)
        settingsJsonTextIO.close()
        if not quiet:
            print("JSON format succesfull saved")
        if debug:
            print("sys.argv[0] =",sys.argv[0])
            print(jsonstring)
    except:
        close_all_gone_wrong("savingJSON", "script at path " + path_full(sys.argv[0]))
    json_test_string = loadjson(filename, quiet=True)
    if jsonstring != json_test_string:
        close_all_gone_wrong("savingJSON", "script at path " + path_full(sys.argv[0]))


def loadjson(filename, quiet = False, debug=False):
    try:
        if not os.path.isfile(filename):
            file_create(filename)
            cleanjson = {}
            savejson(filename, cleanjson)
        settingsJsonTextIO = open(filename)
        jsonStringInMemory = json.load(settingsJsonTextIO)
        settingsJsonTextIO.close()
        if not quiet:
            print("JSON format succesfull loaded")
        if debug:
            print(jsonStringInMemory)
        return jsonStringInMemory
    except:
        close_all_gone_wrong("loadingJSON", "JSON at path" + path_full(filename))


def path_to_quotes(path):
    path = '"' + str(path) + '"'
    return path


def in_quotes(string):
    return path_to_quotes(string)


# def pathInWindowsExtend(*paths):
    # for path_ in paths:
    #     try:
    #         path
    #         path = str(path) + backslash + str(path_)
    #     except:
    #         path = path_
    # return path


def path_extend(*paths):
    for path_ in paths:
        try:
            path
            path = os.path.join(str(path), str(path_))
        except:
            if (get_os() == "windows") and (len(path_) <= 3):
                path = os.path.join(path_, os.sep)
            elif (get_os() == "windows") and path_ == backslash:  # support for smb windows paths like \\ip_or_pcname\something\
                path = backslash * 2
            elif get_os() == "windows":
                path = path_
            elif (get_os() == "macos") or (get_os() == "linux"):
                path = os.path.join(os.sep, path_)
    return path


def taskkill(process):
    command_ = "taskkill /f /im " + str(process) + ".exe"
    os.system(command_)
    return command_


def cls():
    os.system("cls")


def file_wipe(path):
    file = open(path, 'w')
    file.close()


def getIntegers(string):
    string = str(string)
    integerFinded = False
    integers = []
    # cnt = 0
    currentinteger = 0
    for symbol in string:
        try:
            int(symbol)
            currentinteger = currentinteger*10 + int(symbol)
            integerFinded = True
        except:
            if integerFinded:
                integers = integers + [currentinteger]
                currentinteger = 0
                integerFinded = False
            #print(integers)
    return integers


def stringWidthNewlinesToString(string): #todo сделать!
    return string


def getOutPutFromCommand(command, quiet = True):
    p = subprocess.check_output(command, shell=True)
    #p = subprocess.getoutput(command)
    # S.split(newline2) - todo сделать разделение по линиям
    pstr = p.decode("cp866")
    strings = stringWidthNewlinesToString(pstr)
    return strings


def checkWidthOfConsole():
    if get_os() == "windows":
        modecon = getOutPutFromCommand("mode con")
        width = getIntegers(modecon)[1]
    elif get_os() == "macos" or get_os() == "linux":
        sttysize = getOutPutFromCommand("stty size")
        width = getIntegers(sttysize)[1]
    return width


def checkHeightOfConsole():
    if get_os() == "windows":
        modecon = getOutPutFromCommand("mode con")
        width = getIntegers(modecon)[0]
    elif get_os() == "macos" or get_os() == "linux":
        sttysize = getOutPutFromCommand("stty size")
        width = getIntegers(sttysize)[0]
    if height > 100:
        height = 100
    return height


def screenblink(width = None, height = None, symbol = "#", sleep = 0.5, mode = "fast"):
    if width != None and height != None:
        os.system("mode con cols=" + str(width) + " lines=" + str(height))
    if width == None:
        width = checkWidthOfConsole()
    if height == None:
        height = checkHeightOfConsole()
    colorama.reinit()
    while True:
        colors = ["grey", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
        highlights = ["on_grey", "on_red", "on_green", "on_yellow", "on_blue", "on_magenta", "on_cyan", "on_white"]
        string = symbol * width
        color = random.choice(colors)
        colors.pop(colors.index(color))
        highlight = random.choice(highlights)
        if mode == "fast":
            try: # New version with one long line. Works perfect, as I see.
                string = string * height
                print(termcolor.colored(string, color, highlight))
                time.sleep(sleep)
            except KeyboardInterrupt as err:
                print (termcolor.colored("OK", "white", "on_grey"))
                colorama.deinit()
                cls()
                break
        else:
            try: #old multiline version. Have bug with get width of console and so create blank lines. Unexpected
                height_ = height
                while height_ > 0:
                    print(termcolor.colored(string, color, highlight))
                    height_ -= 1
                time.sleep(sleep)
            except KeyboardInterrupt as err:
                print (termcolor.colored("OK", "white", "on_grey"))
                colorama.deinit()
                cls()
                break
    colorama.deinit()


def home_path():
    homepath = getOutPutFromCommand("echo %userprofile%")
    homepath = homepath.rstrip("\r\n") # todo взять на заметку в getOutputFromCommand & stringWidthNewlinesToString
    return homepath


def rustime(customtime = None):
    if customtime:
        # onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime('%Y-%m-%d %H:%M:%S')
        # onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime(r'%d числа %m месяца %Y года в %H:%M:%S')
        # print(onworktime)
        # rustime = onworktime
        day = datetime.datetime.fromtimestamp(customtime).strftime('%d')
        month = datetime.datetime.fromtimestamp(customtime).strftime('%m')
        year = datetime.datetime.fromtimestamp(customtime).strftime('%Y')
        hour = datetime.datetime.fromtimestamp(customtime).strftime('%H')
        minute = datetime.datetime.fromtimestamp(customtime).strftime('%M')
        second = datetime.datetime.fromtimestamp(customtime).strftime('%S')
    else:
        gettime = datetime.datetime.now()
        day = gettime.strftime("%d")
        month = gettime.strftime('%m')
        year = gettime.strftime('%Y')
        hour = gettime.strftime('%H')
        minute = gettime.strftime('%M')
        second = gettime.strftime('%S')
    rustime = str(day) + " числа " + str(month) + " месяца " + str(year) + " года в " \
    + str(hour) + ":" + str(minute) + ":" + str(second)
    return rustime


def plog(logfile, logstring = "some shit happened", customtime = None, quiet = False):
    if not quiet:
        print(logstring)
    file_create(logfile)
    file_backup(logfile, quiet=True)
    file = open(logfile, "a")
    if customtime:
        file.write(rustime(customtime) + " " + str(logstring) + newline)
    else:
        file.write(rustime() + " " + str(logstring) + newline)
    file.close()


def ping(domain ="127.0.0.1", count = 1, quiet = False, logfile = None, timeout = 10000): # с таким эксепшном можно сделать куда проще это всё
    domain = getDomainOfUrl(domain)
    if not quiet:
        colorama.reinit()
        print("Pinging", domain, count, "times...")
        upmessage = domain + " is up!"
        downmessage = domain + " is down."
    try:
        if get_os() == "windows":
            count_arg = "n"
            timeout_arg = "w"
        if (get_os() == "macos") or (get_os() == "linux"):
            count_arg = "c"
            timeout_arg = "W"
        command = "ping " + domain + " -" + count_arg + " " + str(count) + \
                  " -" + timeout_arg + " " + str(timeout)
        pingoutput = getOutPutFromCommand(command)
    except KeyboardInterrupt:
        sys.exit()
    except:
        pingoutput = ""
    if ("TTL" in pingoutput) or ("ttl" in pingoutput):
        up = True
    else:
        up = False
    if logfile:
        if up:
            plog(logfile, domain + " is up!", quiet=True)
            cprint(upmessage, "white", "on_green")
        else:
            plog(logfile, downmessage, quiet=True)
            cprint(downmessage, "white", "on_red")
    elif not quiet:
        if up:
            cprint(upmessage, "white", "on_green")
        else:
            cprint(downmessage, "white", "on_red")
        colorama.deinit()
    return up


def winRepair_UnicodeEncodeError(quiet = ""):
    if quiet == True:
        quiet = " > null"
    os.system("chcp 65001" + quiet)
    os.system("set PYTHONIOENCODING = utf - 8")


def doNothing():
    pass


def input_int(message = "Введите число: ", minimum = None, maximum = None, default = None, quiet = False):
    output_int = "jabla fitta"
    if default:
        message = "(Enter = " + str(default) + ")"
    while output_int == "jabla fitta": # цикл, пока не получит итоговое число
        try:
            integer = input(message)
            if integer != "":
                try:
                    integer = getIntegers(integer)[0]
                except:
                    print("Это не число")
                    raise ValueError
            elif default and integer != "":
                output_int = default
            elif integer == "":
                print("Это не число")
                raise ValueError
            if minimum:
                if int < minimum:
                    print("Число должно быть больше", minimum)
                    raise ValueError
            if maximum:
                if int > maximum:
                    print("Число должно быть меньше", maximum)
                    raise ValueError
            output_int = integer
            break
        except:
            pass
    if not quiet:
        print("Итоговое число:", output_int)
    return output_int


def openInNewWindow(*arguments):
    for argument_ in arguments:
        try:
            command
            command = command + " " + path_to_quotes(argument_)
        except:
            command = 'start "" ' + path_to_quotes(argument_)
    os.system(command)


def openInCurrentWindow(*arguments, commands = []):
    for argument_ in arguments:
        commands.append(str(argument_))
    subprocess.call(commands)


def substring(string, before, after=None):
    startfrom = string.find(before)
    if startfrom != -1:
        startfrom = string.find(before) + len(before)
    else:
        startfrom = 0
    if after:
        end_at = string[startfrom:].find(after)
        if end_at != -1:
            end_at = startfrom + string[startfrom:].find(after)
            substring = string[startfrom:end_at]
        else:
            substring = string[startfrom:]
    else:
        substring = string[startfrom:]
    return substring


def getDomainOfUrl(url):
    url_output = substring(url, "://", "/")
    if url_output == "":
        url_output = substring(url, "://")
    return url_output


def leftpad(string, leng, ch="0", rightpad=False):
    if len(string) >= leng:
        return string
    strOfCh = str(ch) * leng
    string_output = strOfCh[len(string):leng] + string
    if rightpad: # добавление символов справа из аллиаса (rightpad) функции
        string_output = string + strOfCh[len(string):leng]
    return string_output


def rightpad(string, leng, ch = "0"):
    return leftpad(string, leng, ch = ch, rightpad=True)


def bigdigits(digits):
    def digits_init(height = False):
        Zero = ["   ###   ",
                "  #   #  ",
                " #     # ",
                "#       #",
                " #     # ",
                "  #   #  ",
                "   ###   ", ]
        One = ["    #    ",
               "   ##    ",
               "  # #    ",
               "    #    ",
               "    #    ",
               "    #    ",
               " ####### ", ]
        Two = [" ####### ",
               "#       #",
               "        #",
               " ####### ",
               "#        ",
               "#        ",
               "#########", ]
        Three = [" ####### ",
                 "#       #",
                 "        #",
                 "     ### ",
                 "        #",
                 "#       #",
                 " ####### ", ]
        Four = ["#       #",
                "#       #",
                "#       #",
                "#########",
                "        #",
                "        #",
                "        #", ]
        Five = ["#########",
                "#        ",
                "#        ",
                "######## ",
                "        #",
                "#       #",
                " ####### ", ]
        Six = [" ####### ",
               "#       #",
               "#        ",
               "######## ",
               "#       #",
               "#       #",
               " ####### ", ]
        Seven = ["#########",
                 "#       #",
                 "      ## ",
                 "    ##   ",
                 "  ##     ",
                 " #       ",
                 "#        ", ]
        Eight = [" ####### ",
                 "#       #",
                 "#       #",
                 " ####### ",
                 "#       #",
                 "#       #",
                 " ####### ", ]
        Nine = [" ####### ",
                "#       #",
                "#       #",
                " ########",
                "        #",
                "#       #",
                " ####### ", ]
        Digits = [Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine]
        height_int = len(Zero)
        if height:
            return height_int
        else:
            return Digits
    Digits = digits_init()
    column = 0
    while column < digits_init(height = True):
        line = ""
        digits = str(digits)
        for digit in digits:
            # try:
            digit = int(digit)
            line = line + Digits[digit][column] + " "
        print(line)
        column += 1


def tkinter_color(red, green, blue):
    my_color = str('#%02x%02x%02x' % (red, green, blue))
    return my_color


if __name__ == "__main__":
    file_backup(r"\\192.168.99.91\shares\scripts\utilsupdate\utils_dev.py")
    #print(rustime(1487646452.7141206))
    #ping(ip="192.168.99.91")
    #ping(ip="192.168.99.777")
    #screenblink()
    #print(checkWidthOfConsole())
    #print(checkHeightOfConsole())
    #import UtilsUpdate
    while True:
        try:
            command = input(">>")
            exec (command)
            exec("print(" + substring(command, before = '', after=' ') + ")", globals())
        except KeyboardInterrupt:
            sys.exit()
        except SyntaxError as err:
            print(err)



# Есть словарь: my_list = [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
# Сортировка словаря по одному ключу:
# my_list = sorted(my_list, key=lambda k: k['name'])
# Сортировка словаря по нескольким ключам:
# my_list = sorted(my_list, key=lambda x,y : cmp(x['name'], y['name']))
# или
# my_list.sort(lambda x,y : cmp(x['name'], y['name']))
