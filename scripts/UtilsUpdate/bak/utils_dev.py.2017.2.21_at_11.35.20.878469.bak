#! python3
# version 1.0.19_14
# init ver
# f createdirs
# f createfile
# f savejson
# f loadjson
# f pathInWindowsWithSpacesToQuotes
# f pathInWindowsExtend
# ver 1.0.1
# f taskkill
# f jsonload print "json loaded" output
# f jsonsave print "json saved" output
# ver 1.0.2
# f file_wipe
# ver 1.0.3
# f filebackup
# f jsonrestorebak todo
# f jsoncheck todo
# f timestamp
# ver 1.0.4
# f screenblink
# ver 1.0.5
# update pathInWindowsExtend - three path extend now
# ver 1.0.6
# update pathInWindowsExtend - unlimited args now#
# ver 1.0.7
# update pathInWindowsExtend - bugfix
# ver 1.0.8
# update pathInWindowsExtend - bugfix
# ver 1.0.9
# update screenblink - bugfix
# ver 1.0.10
# update screenblink - bugfix
# ver 1.0.11
# update screenblink - bugfix
# ver 1.0.12
# update screenblink - bugfix
# ver 1.0.13
# update screenblink - add change size of console window
# ver 1.0.14
# getOutPutFromCommand
# getIntegers
# stringWidthNewlinesToString todo
# checkWidthOfConsole
# update screenblink
# ver 1.0.15
# enable new functionality in screenblink
# todo вместо вывода кучи строк вывести одну длинную?
# ver 1.0.16
# f homePath
# ver 1.0.17
# loadjson warning expanded
# ver 1.0.18
# f plog
# const newline
# syml gettime
# f rustime
# ver 1.0.19
# plog add custom time todo
# rustime add custom time todo

# todo ping
# todo countdown
# todo cls
# todo version diff

import os, \
       json, \
       sys, \
       shutil, \
       time, \
       termcolor, \
       colorama, \
       random, \
       win_unicode_console, \
       subprocess, \
       datetime
#win_unicode_console.enable()
colorama.init()
colorama.deinit()

gettime = datetime.datetime.now()
newline = '\n'


def createdirs(filename):
    dir = os.path.dirname(filename)
    if not os.path.exists(dir):
        os.makedirs(dir)


def createfile(filename):
    dir = os.path.dirname(filename)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if not os.path.exists(filename):
        open(filename, 'a').close()


def timestamp():
    ts = time.time()
    return ts


def filebackup(filename):
    dateandtime = str(gettime.year) + "." + str(gettime.month) + "." + str(gettime.day) + "_at_" + str(gettime.hour) \
    + "." + str(gettime.minute) + "." + str(gettime.second) + "." + str(gettime.microsecond)
    backupfilename = str(filename) + "." + str(dateandtime) + ".bak"
    shutil.copy2(filename, backupfilename)
    print("backup of file", filename, "created as", backupfilename)


def jsoncheck(filename):
    try:
        loadjson(filename)
    except:
        print("JSON is bad")


def savejson(filename, jsonstring):
    try:
        settingsJsonTextIO = open(filename, "w")
        json.dump(jsonstring, settingsJsonTextIO)
        settingsJsonTextIO.close()
        print("JSON format succesfull saved")
    except:
        print("Error while saving JSON")


def loadjson(filename):
    try:
        settingsJsonTextIO = open(filename)
        jsonStringInMemory = json.load(settingsJsonTextIO)
        settingsJsonTextIO.close()
        print("JSON format succesfull loaded")
        return jsonStringInMemory
    except:
        print("Error while loading JSON")
        print("Try to repair JSON at path", filename)
        print("Script is closing")
        sys.exit()


def pathInWindowsWithSpacesToQuotes(path):
    path = '"' + str(path) + '"'
    return path

def pathInWindowsExtend(*paths):
    for path_ in paths:
        try:
            path
            path = str(path) + "\ "[:1] + str(path_)
        except:
            path = path_
    return path

def taskkill(process):
    command_ = "taskkill /f /im " + str(process) + ".exe"
    os.system(command_)
    return command_


def wipefile(path):
    file = open(path, 'w')
    file.close()


def getIntegers(string):
    string = str(string)
    integerFinded = False
    integers = []
    # cnt = 0
    currentinteger = 0
    for symbol in string:
        try:
            int(symbol)
            currentinteger = currentinteger*10 + int(symbol)
            integerFinded = True
        except:
            if integerFinded:
                integers = integers + [currentinteger]
                currentinteger = 0
                integerFinded = False
            #print(integers)
    return integers



def stringWidthNewlinesToString(string): #todo сделать!
    return string


def getOutPutFromCommand(command):
    p = subprocess.check_output(command, shell=True)
    pstr = p.decode("cp866")
    strings = stringWidthNewlinesToString(pstr)
    return strings


def checkWidthOfConsole():
    modecon = getOutPutFromCommand("mode con")
    width = getIntegers(modecon)[1]
    return width


def checkHeightOfConsole():
    modecon = getOutPutFromCommand("mode con")
    height = getIntegers(modecon)[0]
    if height > 500:
        height = 70
    return height


def screenblink(width = None, height = None, symbol = "#", sleep = 0.5):
    if width != None and height != None:
        os.system("mode con cols=" + str(width) + " lines=" + str(height))
    if width == None:
        width = checkWidthOfConsole()
    if height == None:
        height = checkHeightOfConsole()
    try:
        colorama.reinit()
        while True:
            colors = ["grey", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
            highlights = ["on_grey", "on_red", "on_green", "on_yellow", "on_blue", "on_magenta", "on_cyan", "on_white"]
            string = symbol * width
            color = random.choice(colors)
            colors.pop(colors.index(color))
            highlight = random.choice(highlights)
            #print (termcolor.colored(color + on + highlight,color,highlight))
            try:
                height_ = height
                while height_ > 0:
                #print string
                    print(termcolor.colored(string, color, highlight))
                    height_ -= 1
                time.sleep(sleep)
            except KeyboardInterrupt as err:
                print (termcolor.colored("OK", "white", "on_grey"))
                colorama.deinit()
                os.system("cls")
                break
        colorama.deinit()
    except:
        print("Except1")


def homePath():
    homepath = getOutPutFromCommand("echo %userprofile%")
    homepath = homepath.rstrip("\r\n") # todo взять на заметку в getOutputFromCommand & stringWidthNewlinesToString
    return homepath


def rustime(customtime = None):
    if customtime:
        #onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime('%Y-%m-%d %H:%M:%S')
        onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime(r'%d числа %m месяца %Y года в %H:%M:%S')
        print(onworktime)
        rustime = onworktime
    else:
        rustime = str(gettime.day) + " числа " + str(gettime.month) + " месяца " + str(gettime.year) + " года в " \
        + str(gettime.hour) + ":" + str(gettime.minute) + ":" + str(gettime.second)
    return rustime


def plog(logfile, logstring = "some shit happened", customtime = None):
    #try:
        createfile(logfile)
        filebackup(logfile)
        file = open(logfile, "a")
        if customtime:
            file.write(rustime(customtime) + " " + str(logstring) + newline)
        else:
            file.write(rustime() + " " + str(logstring) + newline)
        file.close()
    #except:
    #    print("Error while logging string")
    #    print("Script is closing")
    #    sys.exit()

if __name__ == "__main__":
    filebackup(r"\\192.168.99.91\shares\scripts\utilsupdate\utils_dev.py")
    plog(logfile=r"\\192.168.99.91\shares\scripts\utilsupdate\utils_dev.log", customtime=1485962802.6988397)

    #screenblink()
    #print(checkWidthOfConsole())
    #print(checkHeightOfConsole())
    #import UtilsUpdate