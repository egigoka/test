#! python3
# version 1.0.22
# init ver
# f createdirs
# f createfile
# f savejson
# f loadjson
# f pathInWindowsWithSpacesToQuotes
# f pathInWindowsExtend
# ver 1.0.1
# f taskkill
# f jsonload print "json loaded" output
# f jsonsave print "json saved" output
# ver 1.0.2
# f file_wipe
# ver 1.0.3
# f filebackup
# f jsonrestorebak todo
# f jsoncheck todo
# f timestamp
# ver 1.0.4
# f screenblink
# ver 1.0.5
# update pathInWindowsExtend - three path extend now
# ver 1.0.6
# update pathInWindowsExtend - unlimited args now#
# ver 1.0.7
# update pathInWindowsExtend - bugfix
# ver 1.0.8
# update pathInWindowsExtend - bugfix
# ver 1.0.9
# update screenblink - bugfix
# ver 1.0.10
# update screenblink - bugfix
# ver 1.0.11
# update screenblink - bugfix
# ver 1.0.12
# update screenblink - bugfix
# ver 1.0.13
# update screenblink - add change size of console window
# ver 1.0.14
# getOutPutFromCommand
# getIntegers
# stringWidthNewlinesToString todo
# checkWidthOfConsole
# update screenblink
# ver 1.0.15
# enable new functionality in screenblink
# todo вместо вывода кучи строк вывести одну длинную?
# ver 1.0.16
# f homePath
# ver 1.0.17
# loadjson warning expanded
# ver 1.0.18
# f plog
# const newline
# syml gettime
# f rustime
# ver 1.0.19
# plog add custom time
# rustime add custom time
# ver 1.0.20
# loadjson quiet option
# ver 1.0.21
# filebackup quiet option
# ver 1.0.22
# f ping

# todo ping
# todo countdown
# todo cls
# todo version diff

import os, \
       json, \
       sys, \
       shutil, \
       time, \
       termcolor, \
       colorama, \
       random, \
       win_unicode_console, \
       subprocess, \
       datetime
#win_unicode_console.enable()
colorama.init()
colorama.deinit()
from termcolor import colored, cprint #print_green_on_cyan = lambda x: cprint(x, 'green', 'on_cyan')

gettime = datetime.datetime.now()
newline = '\n'


def createdirs(filename):
    dir = os.path.dirname(filename)
    if not os.path.exists(dir):
        os.makedirs(dir)


def createfile(filename):
    dir = os.path.dirname(filename)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if not os.path.exists(filename):
        open(filename, 'a').close()


def timestamp():
    ts = time.time()
    return ts


def filebackup(filename, quiet = False):
    dateandtime = str(gettime.year) + "." + str(gettime.month) + "." + str(gettime.day) + "_at_" + str(gettime.hour) \
    + "." + str(gettime.minute) + "." + str(gettime.second) + "." + str(gettime.microsecond)
    backupfilename = str(filename) + "." + str(dateandtime) + ".bak"
    shutil.copy2(filename, backupfilename)
    if not quiet:
        print("backup of file", filename, "created as", backupfilename)


def jsoncheck(filename):
    try:
        loadjson(filename)
    except:
        print("JSON is bad")


def savejson(filename, jsonstring):
    try:
        settingsJsonTextIO = open(filename, "w")
        json.dump(jsonstring, settingsJsonTextIO)
        settingsJsonTextIO.close()
        print("JSON format succesfull saved")
    except:
        print("Error while saving JSON")


def loadjson(filename, quiet = False):
    try:
        settingsJsonTextIO = open(filename)
        jsonStringInMemory = json.load(settingsJsonTextIO)
        settingsJsonTextIO.close()
        if not quiet:
            print("JSON format succesfull loaded")
        return jsonStringInMemory
    except:
        print("Error while loading JSON")
        print("Try to repair JSON at path", filename)
        print("Script is closing")
        sys.exit()


def pathInWindowsWithSpacesToQuotes(path):
    path = '"' + str(path) + '"'
    return path

def pathInWindowsExtend(*paths):
    for path_ in paths:
        try:
            path
            path = str(path) + "\ "[:1] + str(path_)
        except:
            path = path_
    return path

def taskkill(process):
    command_ = "taskkill /f /im " + str(process) + ".exe"
    os.system(command_)
    return command_


def wipefile(path):
    file = open(path, 'w')
    file.close()


def getIntegers(string):
    string = str(string)
    integerFinded = False
    integers = []
    # cnt = 0
    currentinteger = 0
    for symbol in string:
        try:
            int(symbol)
            currentinteger = currentinteger*10 + int(symbol)
            integerFinded = True
        except:
            if integerFinded:
                integers = integers + [currentinteger]
                currentinteger = 0
                integerFinded = False
            #print(integers)
    return integers



def stringWidthNewlinesToString(string): #todo сделать!
    return string


def getOutPutFromCommand(command, quiet = True):
    try:
        p = subprocess.getoutput(command, shell=True)
    except CalledProcessError:
        print("Yeah")
    pstr = p.decode("cp866")
    strings = stringWidthNewlinesToString(pstr)
    return strings


def checkWidthOfConsole():
    modecon = getOutPutFromCommand("mode con")
    width = getIntegers(modecon)[1]
    return width


def checkHeightOfConsole():
    modecon = getOutPutFromCommand("mode con")
    height = getIntegers(modecon)[0]
    if height > 500:
        height = 70
    return height


def screenblink(width = None, height = None, symbol = "#", sleep = 0.5):
    if width != None and height != None:
        os.system("mode con cols=" + str(width) + " lines=" + str(height))
    if width == None:
        width = checkWidthOfConsole()
    if height == None:
        height = checkHeightOfConsole()
    try:
        colorama.reinit()
        while True:
            colors = ["grey", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
            highlights = ["on_grey", "on_red", "on_green", "on_yellow", "on_blue", "on_magenta", "on_cyan", "on_white"]
            string = symbol * width
            color = random.choice(colors)
            colors.pop(colors.index(color))
            highlight = random.choice(highlights)
            #print (termcolor.colored(color + on + highlight,color,highlight))
            try:
                height_ = height
                while height_ > 0:
                #print string
                    print(termcolor.colored(string, color, highlight))
                    height_ -= 1
                time.sleep(sleep)
            except KeyboardInterrupt as err:
                print (termcolor.colored("OK", "white", "on_grey"))
                colorama.deinit()
                os.system("cls")
                break
        colorama.deinit()
    except:
        print("Except1")


def homePath():
    homepath = getOutPutFromCommand("echo %userprofile%")
    homepath = homepath.rstrip("\r\n") # todo взять на заметку в getOutputFromCommand & stringWidthNewlinesToString
    return homepath


def rustime(customtime = None):
    if customtime:
        # onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime('%Y-%m-%d %H:%M:%S')
        # onworktime = datetime.datetime.fromtimestamp(int(customtime)).strftime(r'%d числа %m месяца %Y года в %H:%M:%S')
        # print(onworktime)
        # rustime = onworktime
        day = datetime.datetime.fromtimestamp(customtime).strftime('%d')
        month = datetime.datetime.fromtimestamp(customtime).strftime('%m')
        year = datetime.datetime.fromtimestamp(customtime).strftime('%Y')
        hour = datetime.datetime.fromtimestamp(customtime).strftime('%H')
        minute = datetime.datetime.fromtimestamp(customtime).strftime('%M')
        second = datetime.datetime.fromtimestamp(customtime).strftime('%S')
    else:
        day = gettime.day
        month = gettime.month
        year = gettime.year
        hour = gettime.hour
        minute = gettime.minute
        second = gettime.second
    rustime = str(day) + " числа " + str(month) + " месяца " + str(year) + " года в " \
    + str(hour) + ":" + str(minute) + ":" + str(second)
    return rustime


def plog(logfile, logstring = "some shit happened", customtime = None, quiet = False):
    if not quiet:
        print(logstring)
    createfile(logfile)
    filebackup(logfile, quiet=True)
    file = open(logfile, "a")
    if customtime:
        file.write(rustime(customtime) + " " + str(logstring) + newline)
    else:
        file.write(rustime() + " " + str(logstring) + newline)
    file.close()

def ping(ip = "127.0.0.1", count = 1, quiet = False, logfile = None): # с таким эксепшном можно сделать куда проще это всё
    if not quiet:
        colorama.reinit()
        print("Pinging", ip, count, "times...")
        upmessage = ip + " is up!"
        downmessage = ip + " is down."
    try:
        pingoutput = getOutPutFromCommand("ping " + ip + " -n " + str(count))
    except Exception as e:
        do="nothing"
    if "TTL" in pingoutput:
        up = True
    else:
        up = False
    if logfile:
        if up:
            plog(logfile, ip + " is up!", quiet=True)
            cprint(upmessage, "white", "on_green")
        else:
            plog(logfile, downmessage, quiet=True)
            cprint(downmessage, "white", "on_red")
    elif not quiet:
        if up:
            cprint(upmessage, "white", "on_green")
        else:
            cprint(downmessage, "white", "on_red")
        colorama.deinit()
    return up

if __name__ == "__main__":
    filebackup(r"\\192.168.99.91\shares\scripts\utilsupdate\utils_dev.py")
    #print(rustime(1487646452.7141206))
    ping(ip="192.168.99.91")
    ping(ip="192.168.99.777")
    #screenblink()
    #print(checkWidthOfConsole())
    #print(checkHeightOfConsole())
    #import UtilsUpdate